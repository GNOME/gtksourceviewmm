// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gtksourceviewmm/sourcebuffer.h>
#include <gtksourceviewmm/private/sourcebuffer_p.h>

/* sourcebuffer.hg
 * 
 * Copyright (C) 2005-2006 The gtksourceviewmm development team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
#include <gtksourceviewmm/sourcebuffer.h>

namespace gtksourceview
{

SourceBuffer::SourceBuffer (Glib::RefPtr<SourceLanguage> &language) :
    Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init(), (char*) 0))
{
    if (language)
    {
        gtk_source_buffer_set_language (GTK_SOURCE_BUFFER (gobject_),
                                        language->gobj ()) ;
    }
    else
    {
        gtk_source_buffer_set_language (GTK_SOURCE_BUFFER (gobject_),
                                        NULL) ;
    }
}

}//end namespace gtksourceview


namespace
{

void SourceBuffer_signal_can_redo_callback(GtkSourceBuffer* self, gboolean p0,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo SourceBuffer_signal_can_redo_info =
{
  "can-redo",
  (GCallback) &SourceBuffer_signal_can_redo_callback,
  (GCallback) &SourceBuffer_signal_can_redo_callback
};


void SourceBuffer_signal_can_undo_callback(GtkSourceBuffer* self, gboolean p0,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo SourceBuffer_signal_can_undo_info =
{
  "can-undo",
  (GCallback) &SourceBuffer_signal_can_undo_callback,
  (GCallback) &SourceBuffer_signal_can_undo_callback
};


void SourceBuffer_signal_highlight_updated_callback(GtkSourceBuffer* self, GtkTextIter* p0,GtkTextIter* p1,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,Gtk::TextIter &,Gtk::TextIter & > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0)
, Glib::wrap(p1)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo SourceBuffer_signal_highlight_updated_info =
{
  "highlight-updated",
  (GCallback) &SourceBuffer_signal_highlight_updated_callback,
  (GCallback) &SourceBuffer_signal_highlight_updated_callback
};


void SourceBuffer_signal_marker_updated_callback(GtkSourceBuffer* self, GtkTextIter* p0,void* data)
{
  using namespace gtksourceview;
  typedef sigc::slot< void,Gtk::TextIter & > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo SourceBuffer_signal_marker_updated_info =
{
  "marker-updated",
  (GCallback) &SourceBuffer_signal_marker_updated_callback,
  (GCallback) &SourceBuffer_signal_marker_updated_callback
};

} // anonymous namespace


namespace Glib
{

Glib::RefPtr<gtksourceview::SourceBuffer> wrap(GtkSourceBuffer* object, bool take_copy)
{
  return Glib::RefPtr<gtksourceview::SourceBuffer>( dynamic_cast<gtksourceview::SourceBuffer*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace gtksourceview
{


/* The *_Class implementation: */

const Glib::Class& SourceBuffer_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &SourceBuffer_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_source_buffer_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  }

  return *this;
}

void SourceBuffer_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

  klass->can_redo = &can_redo_callback;
  klass->can_undo = &can_undo_callback;
  klass->highlight_updated = &highlight_updated_callback;
  klass->marker_updated = &marker_updated_callback;
}


void SourceBuffer_Class::can_redo_callback(GtkSourceBuffer* self, gboolean p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_can_redo(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->can_redo)
      (*base->can_redo)(self, p0);
  }
}

void SourceBuffer_Class::can_undo_callback(GtkSourceBuffer* self, gboolean p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_can_undo(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->can_undo)
      (*base->can_undo)(self, p0);
  }
}

void SourceBuffer_Class::highlight_updated_callback(GtkSourceBuffer* self, GtkTextIter* p0, GtkTextIter* p1)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_highlight_updated(Glib::wrap(p0)
, Glib::wrap(p1)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->highlight_updated)
      (*base->highlight_updated)(self, p0, p1);
  }
}

void SourceBuffer_Class::marker_updated_callback(GtkSourceBuffer* self, GtkTextIter* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_marker_updated(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->marker_updated)
      (*base->marker_updated)(self, p0);
  }
}


Glib::ObjectBase* SourceBuffer_Class::wrap_new(GObject* object)
{
  return new SourceBuffer((GtkSourceBuffer*)object);
}


/* The implementation: */

GtkSourceBuffer* SourceBuffer::gobj_copy()
{
  reference();
  return gobj();
}

SourceBuffer::SourceBuffer(const Glib::ConstructParams& construct_params)
:
  Gtk::TextBuffer(construct_params)
{}

SourceBuffer::SourceBuffer(GtkSourceBuffer* castitem)
:
  Gtk::TextBuffer((GtkTextBuffer*)(castitem))
{}

SourceBuffer::~SourceBuffer()
{}


SourceBuffer::CppClassType SourceBuffer::sourcebuffer_class_; // initialize static member

GType SourceBuffer::get_type()
{
  return sourcebuffer_class_.init().get_type();
}

GType SourceBuffer::get_base_type()
{
  return gtk_source_buffer_get_type();
}


SourceBuffer::SourceBuffer()
:
  Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init()))
{
  }

SourceBuffer::SourceBuffer(Glib::RefPtr<SourceTagTable> & tagtable)
:
  Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Gtk::TextBuffer(Glib::ConstructParams(sourcebuffer_class_.init(), "tagtable", Glib::unwrap(tagtable), (char*) 0))
{
  }

Glib::RefPtr<SourceBuffer> SourceBuffer::create(Glib::RefPtr<SourceTagTable> & tagtable)
{
  return Glib::RefPtr<SourceBuffer>( new SourceBuffer(tagtable) );
}
Glib::RefPtr<SourceBuffer> SourceBuffer::create(Glib::RefPtr<SourceLanguage> & language)
{
  return Glib::RefPtr<SourceBuffer>( new SourceBuffer(language) );
}
bool SourceBuffer::get_check_brackets()
{
  return gtk_source_buffer_get_check_brackets(gobj());
}

void SourceBuffer::set_check_brackets(bool check_brackets)
{
  gtk_source_buffer_set_check_brackets(gobj(), static_cast<int>(check_brackets));
}

void SourceBuffer::set_bracket_match_style(const SourceTagStyle& style)
{
  gtk_source_buffer_set_bracket_match_style(gobj(), style.gobj());
}

bool SourceBuffer::get_highlight()
{
  return gtk_source_buffer_get_highlight(gobj());
}

void SourceBuffer::set_highlight(bool highlight)
{
  gtk_source_buffer_set_highlight(gobj(), static_cast<int>(highlight));
}

int SourceBuffer::get_max_undo_levels()
{
  return gtk_source_buffer_get_max_undo_levels(gobj());
}

void SourceBuffer::set_max_undo_levels(int max_undo_levels)
{
  gtk_source_buffer_set_max_undo_levels(gobj(), max_undo_levels);
}

Glib::RefPtr<SourceLanguage> SourceBuffer::get_language()
{
  return Glib::wrap(gtk_source_buffer_get_language(gobj()));
}

void SourceBuffer::set_language(Glib::RefPtr<SourceLanguage> language)
{
  gtk_source_buffer_set_language(gobj(), Glib::unwrap(language));
}

gunichar SourceBuffer::get_escape_char()
{
  return gtk_source_buffer_get_escape_char(gobj());
}

void SourceBuffer::set_escape_char(gunichar escape_char)
{
  gtk_source_buffer_set_escape_char(gobj(), escape_char);
}

bool SourceBuffer::can_undo()
{
  return gtk_source_buffer_can_undo(gobj());
}

bool SourceBuffer::can_redo()
{
  return gtk_source_buffer_can_redo(gobj());
}

void SourceBuffer::undo()
{
  gtk_source_buffer_undo(gobj());
}

void SourceBuffer::redo()
{
  gtk_source_buffer_redo(gobj());
}

void SourceBuffer::begin_not_undoable_action()
{
  gtk_source_buffer_begin_not_undoable_action(gobj());
}

void SourceBuffer::end_notundoable_action()
{
  gtk_source_buffer_end_not_undoable_action(gobj());
}

Glib::RefPtr<SourceMarker> SourceBuffer::create_marker(const Glib::ustring& name, const Glib::ustring& type, const Gtk::TextIter& where)
{
  return Glib::wrap(gtk_source_buffer_create_marker(gobj(), name.c_str(), type.c_str(), where.gobj()));
}

void SourceBuffer::move_marker(Glib::RefPtr<SourceMarker> p1, const Gtk::TextIter& where)
{
  gtk_source_buffer_move_marker(gobj(), Glib::unwrap(p1), where.gobj());
}

void SourceBuffer::delete_marker(Glib::RefPtr<SourceMarker> p1)
{
  gtk_source_buffer_delete_marker(gobj(), Glib::unwrap(p1));
}

Glib::RefPtr<SourceMarker> SourceBuffer::get_marker(const Glib::ustring& name)
{
  return Glib::wrap(gtk_source_buffer_get_marker(gobj(), name.c_str()));
}

Glib::SListHandle<Glib::RefPtr<SourceMarker> > SourceBuffer::get_markers_in_region(const Gtk::TextIter& begin, const Gtk::TextIter& end)
{
  return Glib::SListHandle<Glib::RefPtr<SourceMarker> >(gtk_source_buffer_get_markers_in_region(gobj(), begin.gobj(), end.gobj()), Glib::OWNERSHIP_SHALLOW);
}

Glib::RefPtr<SourceMarker> SourceBuffer::get_first_marker()
{
  return Glib::wrap(gtk_source_buffer_get_first_marker(gobj()));
}

Glib::RefPtr<SourceMarker> SourceBuffer::get_last_marker()
{
  return Glib::wrap(gtk_source_buffer_get_last_marker(gobj()));
}

Glib::RefPtr<SourceMarker> SourceBuffer::get_next_marker(Gtk::TextIter& iter)
{
  return Glib::wrap(gtk_source_buffer_get_next_marker(gobj(), iter.gobj()));
}

Glib::RefPtr<SourceMarker> SourceBuffer::get_prev_marker(Gtk::TextIter& iter)
{
  return Glib::wrap(gtk_source_buffer_get_prev_marker(gobj(), iter.gobj()));
}


Glib::SignalProxy1< void,bool > SourceBuffer::signal_can_redo()
{
  return Glib::SignalProxy1< void,bool >(this, &SourceBuffer_signal_can_redo_info);
}

Glib::SignalProxy1< void,bool > SourceBuffer::signal_can_undo()
{
  return Glib::SignalProxy1< void,bool >(this, &SourceBuffer_signal_can_undo_info);
}

Glib::SignalProxy2< void,Gtk::TextIter &,Gtk::TextIter & > SourceBuffer::signal_highlight_updated()
{
  return Glib::SignalProxy2< void,Gtk::TextIter &,Gtk::TextIter & >(this, &SourceBuffer_signal_highlight_updated_info);
}

Glib::SignalProxy1< void,Gtk::TextIter & > SourceBuffer::signal_marker_updated()
{
  return Glib::SignalProxy1< void,Gtk::TextIter & >(this, &SourceBuffer_signal_marker_updated_info);
}


void gtksourceview::SourceBuffer::on_can_redo(bool can_redo)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->can_redo)
    (*base->can_redo)(gobj(),static_cast<int>(can_redo));
}

void gtksourceview::SourceBuffer::on_can_undo(bool can_redo)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->can_undo)
    (*base->can_undo)(gobj(),static_cast<int>(can_redo));
}

void gtksourceview::SourceBuffer::on_highlight_updated(Gtk::TextIter & start, Gtk::TextIter & end)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->highlight_updated)
    (*base->highlight_updated)(gobj(),start.gobj(),end.gobj());
}

void gtksourceview::SourceBuffer::on_marker_updated(Gtk::TextIter & where)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->marker_updated)
    (*base->marker_updated)(gobj(),where.gobj());
}


} // namespace gtksourceview


