/* sourcebuffer.hg
 * 
 * Copyright (C) 2004-2005 Jae Jang
 * Copyright (C) 2005-2006 Rob Page
 * Copyright (C) 2006 Dodji Seketeli
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/// \file
/// \brief SourceBuffer class
///

#include <gtkmm/textbuffer.h>
#include <gtksourceviewmm/sourcelanguage.h>
#include <gtksourceviewmm/sourcemark.h>

_DEFS(gtksourceviewmm,gtksourceview)
_PINCLUDE(gtkmm/private/textbuffer_p.h)

namespace gtksourceview
{

/// \brief The model for SourceView widgets.
///
/// It extends the TextBuffer object by adding features necessary
/// to display and edit source code: syntax highlighting,
/// bracket matching and markers.
/// It also implements support for undo/redo operations.
/// To create a SourceBuffer use SourceBuffer::create().
/// By default highlighting is enabled, but you can disable it
/// with SourceBuffer::set_highlight_syntax().
/// This can be useful if you're not using SourceLanguage
/// objects to set the highlighting patterns,
/// and instead you're manually adding SourceTag objects
/// to the buffer's tag table.
class SourceBuffer : public Gtk::TextBuffer
{
  _CLASS_GOBJECT(SourceBuffer, GtkSourceBuffer, GTK_SOURCE_BUFFER, Gtk::TextBuffer, GtkTextBuffer)

protected:
  _CTOR_DEFAULT

#m4 _CONVERSION(`const Glib::RefPtr<Gtk::TextTagTable>&',`GtkTextTagTable*',__CONVERT_REFPTR_TO_P)

  _WRAP_CTOR(SourceBuffer(const Glib::RefPtr<Gtk::TextTagTable>& tagtable), gtk_source_buffer_new)
  explicit SourceBuffer (const Glib::RefPtr<SourceLanguage> &language) ;

public:

    /// \brief create a new SourceBuffer, from a Gtk::TextTagTable.
    ///
    /// \param tagtable a tag table to be taken in account
    /// \return a new SourceBuffer
   _WRAP_CREATE(const Glib::RefPtr<Gtk::TextTagTable>& tagtable)

    /// brief create a new SourceBuffer
    ///
    /// \param language the language to be considered by the SourceBuffer for syntax highlighting.
    /// \return a new SourceBuffer
   _WRAP_CREATE(const Glib::RefPtr<SourceLanguage>& language)

   /// \brief Determines whether bracket match highlighting is activated for the source buffer.
   ///
   /// \return true if the source buffer will highlight  matching brackets, false otherwise.
  _WRAP_METHOD(bool get_highlight_matching_brackets() const, gtk_source_buffer_get_highlight_matching_brackets)

   /// \brief controls the bracket match highlighting function in the buffer.
   ///
   /// If activated, when you position your cursor over a bracket character (a parenthesis, a square bracket, etc.)
   /// the matching opening or closing bracket character will be highlighted.
   /// You can specify the style with the SourceBuffer::set_bracket_match_style() function.
   /// \param highlight true if you want matching brackets highlighted.
  _WRAP_METHOD(void set_highlight_matching_brackets(bool highlight=true), gtk_source_buffer_set_highlight_matching_brackets)

  /// \brief Determines whether text highlighting is activated in the source buffer.
  ///
  /// \return true if highlighting is activated, false otherwise.
  _WRAP_METHOD(bool get_highlight_syntax() const, gtk_source_buffer_get_highlight_syntax)

  /// \brief controls whether text is highlighted in the buffer.
  ///
  /// If highlight is TRUE, the text will be highlighted according to the patterns
  /// installed in the buffer (either set with SourceBuffer::set_language()
  /// or by adding individual GtkSourceTag tags to the buffer's tag table).
  /// Otherwise, any current highlighted text will be restored to the default buffer style.
  /// Tags not of SourceTag type will not be removed by this option, and normal
  /// Gtk::TextTag priority settings apply when highlighting is enabled.
  /// If not using a SourceLanguage for setting the highlighting patterns in the buffer,
  /// it is recommended for performance reasons that you add all the
  /// SourceTag tags with highlighting disabled and enable it when finished.
  /// \param highlight true if you want to activate highlighting
  _WRAP_METHOD(void set_highlight_syntax(bool highlight = true), gtk_source_buffer_set_highlight_syntax)

  /// \brief Determines the number of undo levels the buffer will track for buffer edits.
  ///
  /// \return the maximum number of possible undo levels.
  _WRAP_METHOD(int get_max_undo_levels() const, gtk_source_buffer_get_max_undo_levels)

  /// \brief Sets the number of undo levels for user actions the buffer will track.
  ///
  /// If the number of user actions exceeds the limit set
  /// by this function, older actions will be discarded.
  /// A new action is started whenever the function
  /// Gtk::TextBuffer::begin_user_action() is called.
  /// In general, this happens whenever the user presses
  /// any key which modifies the buffer,
  /// but the undo manager will try to merge similar consecutive actions,
  /// such as multiple character insertions into one action.
  /// But, inserting a newline does start a new action.
  /// \param max_undo_levels the desired maximum number of undo levels.
  _WRAP_METHOD(void set_max_undo_levels(int max_undo_levels), gtk_source_buffer_set_max_undo_levels)

  /// \brief Determines the GtkSourceLanguage used by the buffer.
  ///
  /// \return the SourceLanguage set by SourceBuffer::set_language(), or nil.
  _WRAP_METHOD(Glib::RefPtr<SourceLanguage> get_language(), gtk_source_buffer_get_language, refreturn)

  /// \brief Determines the GtkSourceLanguage used by the buffer.
  ///
  /// \return the SourceLanguage set by SourceBuffer::set_language(), or nil.
  _WRAP_METHOD(Glib::RefPtr<const SourceLanguage> get_language() const, gtk_source_buffer_get_language, refreturn, constversion)


  /// \brief Sets the GtkSourceLanguage the source buffer will use.
  ///
  /// This adds GtkSourceTag tags with the language's patterns and sets
  /// the escape character with SourceBuffer::set_escape_char().
  /// Note that this will remove any SourceTag tags currently
  /// in the buffer's tag table.
  /// The buffer holds a reference to the language set.
  /// \param language a GtkSourceLanguage to set.
  _WRAP_METHOD(void set_language(const Glib::RefPtr<SourceLanguage>& language), gtk_source_buffer_set_language)

  /// \brief Determines the escaping character used by the source buffer highlighting engine.
  ///
  ///\return the UTF-8 character for the escape character the buffer is using.
  _WRAP_METHOD(gunichar get_escape_char() const, gtk_source_buffer_get_escape_char)

  /// \brief Sets the escape character to be used by the highlighting engine.
  ///
  /// When performing the initial analysis,
  /// the engine will discard a matching syntax pattern if it's prefixed
  /// with an odd number of escape characters.
  /// This allows for example to correctly highlight strings with escaped quotes embedded.
  /// This setting affects only syntax patterns (i.e. those defined in GtkSyntaxTag tags).
  /// \param escape_char the escape character the buffer should use.
  _WRAP_METHOD(void set_escape_char(gunichar escape_char), gtk_source_buffer_set_escape_char)

  /// \brief Determines whether a source buffer can undo the last action
  /// \return true if it's possible to undo the last action, false otherwise.
  _WRAP_METHOD(bool can_undo() const, gtk_source_buffer_can_undo)

  /// \brief Determines whether a source buffer can redo the last action
  ///
  /// I.E  if the last operation was an undo.
  /// \return true if it's possible to redo the last action, false otherwise.
  _WRAP_METHOD(bool can_redo() const, gtk_source_buffer_can_redo)

  /// \brief Undoes the last user action which modified the buffer.
  ///
  /// Use SourceBuffer::can_undo() to check whether
  /// a call to this function will have any effect.
  /// Actions are defined as groups of operations
  /// between a call to TextBuffer::begin_user_action()
  /// and TextBuffer::end_user_action(),
  /// or sequences of similar edits
  /// (inserts or deletes) on the same line.
  _WRAP_METHOD(void undo(), gtk_source_buffer_undo)

  /// \brief redoes the last undo operation.
  ///
  /// Use SourceBuffer::can_redo() to check whether
  /// a call to this function will have any effect.
  _WRAP_METHOD(void redo(), gtk_source_buffer_redo)

  /// \brief  Marks the beginning of a not undoable action on the buffer, disabling the undo manager.
  ///
  /// Typically you would call this function before
  /// initially setting the contents of the buffer (e.g. when loading a file in a text editor).
  /// You may nest SourceBuffer::begin_not_undoable_action() / SourceBuffer::end_not_undoable_action() blocks.
  _WRAP_METHOD(void begin_not_undoable_action(), gtk_source_buffer_begin_not_undoable_action)

  /// \brief  Marks the end of a not undoable action on the buffer.
  ///
  /// When the last not undoable block is closed through the call to this function,
  /// the list of undo actions is cleared and the undo manager is re-enabled.
  _WRAP_METHOD(void end_not_undoable_action(), gtk_source_buffer_end_not_undoable_action)

  _WRAP_METHOD(bool backward_iter_to_mark(Gtk::TextIter& iter, const Glib::ustring& category), gtk_source_buffer_backward_iter_to_mark)
  // overload with category == NULL
  bool backward_iter_to_mark(Gtk::TextIter& iter);

  _WRAP_METHOD(bool forward_iter_to_mark(Gtk::TextIter& iter, const Glib::ustring& category), gtk_source_buffer_forward_iter_to_mark)
  // overload with category == NULL
  bool forward_iter_to_mark(Gtk::TextIter& iter);

  _WRAP_METHOD(void ensure_highlight(const Gtk::TextIter& start, const Gtk::TextIter& end), gtk_source_buffer_ensure_highlight)
  _WRAP_METHOD(void set_style_scheme(const Glib::RefPtr<SourceStyleScheme>& scheme), gtk_source_buffer_set_style_scheme)
  _WRAP_METHOD(Glib::RefPtr<SourceStyleScheme> get_style_scheme(), gtk_source_buffer_get_style_scheme, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const SourceStyleScheme> get_style_scheme() const, gtk_source_buffer_get_style_scheme, constversion, refreturn)
  _WRAP_METHOD(Glib::RefPtr<SourceMark> create_mark(const Glib::ustring& name, const Glib::ustring& category, const Gtk::TextIter& where), gtk_source_buffer_create_mark)

#m4 _CONVERSION(`GSList*',`Glib::SListHandle<Glib::RefPtr<SourceMark> >', `$2($3, Glib::OWNERSHIP_SHALLOW)')
#m4 _CONVERSION(`GSList*',`Glib::SListHandle<Glib::RefPtr<const SourceMark> >', `$2($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(Glib::SListHandle<Glib::RefPtr<SourceMark> > get_marks_at_line(int line, const Glib::ustring& category) const, gtk_source_buffer_get_marks_at_line)

  // overloaded with category == NULL
  Glib::SListHandle<Glib::RefPtr<SourceMark> > get_marks_at_line(int line) const;
  _WRAP_METHOD(Glib::SListHandle<Glib::RefPtr<SourceMark> > get_marks_at_iter(Gtk::TextIter& iter, const Glib::ustring& category) const, gtk_source_buffer_get_marks_at_iter)
  // overloaded with category == NULL
  Glib::SListHandle<Glib::RefPtr<SourceMark> > get_marks_at_iter(Gtk::TextIter& iter) const;


  /// \name signals
  /// @{

  /// \brief Emitted whenever there is a change in the buffer's ability to redo an operation.
  ///
  /// parameter can_redo: true if the buffer can now perform a redo, false otherwise.
  _WRAP_SIGNAL(void can_redo(bool can_redo), "can-redo")

  /// \brief Emitted whenever there is a change in the buffer's ability to undo an operation.
  ///
  /// parameter can_undo: true if the buffer can now perfom  an undo, false otherwise.
  _WRAP_SIGNAL(void can_undo(bool can_redo), "can-undo")

  /// \brief Emitted whenever the syntax highlighting information has been updated,
  /// so that views can request a redraw if the region changed is visible.
  ///
  /// Usually only view widgets displaying this buffer will be interested in this signal.
  /// parameter start: an iterator at the start of the updated region.
  /// parameter end: and iterator at the end of the updated region.
  _WRAP_SIGNAL(void highlight_updated(Gtk::TextIter& start, Gtk::TextIter& end), "highlight-updated", no_default_handler)

  /// \brief Emitted whenever a marker of sourcebuffer has changed and needs to be redisplayed by the view.
  ///
  /// A change in a marker's type or location can trigger this signal.
  /// Note that moving a marker causes the emission of this signal twice: one for the old location and one for the new. 
  /// parameter where:  an iterator at the location where the change occurred.
  _WRAP_SIGNAL(void marker_updated(Gtk::TextIter &where), "marker-updated", no_default_handler)
  /// @}
};

} /* namespace gtksourceview */
